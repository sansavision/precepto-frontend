"use client";
import {
  require_react_dom
} from "./chunk-VGGCA2L5.js";
import {
  require_react
} from "./chunk-73THXJN7.js";
import {
  __toESM
} from "./chunk-2TUXWMP5.js";

// node_modules/million/dist/shared/million.b61aa45e.mjs
var Object$ = Object;
var Map$ = Map;
var Set$ = Set;
var SetHas$ = Set$.prototype.has;
var SetAdd$ = Set$.prototype.add;
var MapHas$ = Map$.prototype.has;
var MapGet$ = Map$.prototype.get;
var MapSet$ = Map$.prototype.set;
var ChildFlag = 1;
var AttributeFlag = 2;
var EventFlag = 4;
var StyleAttributeFlag = 8;
var SvgAttributeFlag = 16;
var BlockFlag = 32;
var TEXT_NODE_CACHE = "__t";
var EVENT_PATCH = "__p";
var EVENTS_REGISTRY = "__e";
var IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
var XLINK_NS = "http://www.w3.org/1999/xlink";
var XML_NS = "http://www.w3.org/2000/xmlns/";
var X_CHAR = 120;
var NON_PROPS = new Set$(["href", "list", "form", "tabIndex", "download"]);
var VOID_ELEMENTS = new Set$(["area", "base", "basefont", "bgsound", "br", "col", "command", "embed", "frame", "hr", "image", "img", "input", "isindex", "keygen", "link", "menuitem", "meta", "nextid", "param", "source", "track", "wbr"]);
if (typeof window === "undefined") {
  throw new Error(
    "See http://million.dev/docs/install to install the compiler."
  );
}
var document$ = document;
document$.createElement("template");
var HTM_TEMPLATE = document$.createElement("template");
var HTM_TEMPLATE_CONTENT = HTM_TEMPLATE.content;
var SVG_TEMPLATE = document$.createElementNS(
  "http://www.w3.org/2000/svg",
  "svg"
);
var node$ = Node.prototype;
var element$ = Element.prototype;
var characterData$ = CharacterData.prototype;
var getOwnPropertyDescriptor$ = Object$.getOwnPropertyDescriptor;
var insertBefore$ = node$.insertBefore;
var cloneNode$ = node$.cloneNode;
var replaceChild$ = node$.replaceChild;
var remove$$1 = element$.remove;
var addEventListener$ = node$.addEventListener;
var removeAttribute$ = element$.removeAttribute;
var setAttribute$ = element$.setAttribute;
var setAttributeNS$ = element$.setAttributeNS;
var setTextContent$ = getOwnPropertyDescriptor$(node$, "textContent").set;
var firstChild$ = getOwnPropertyDescriptor$(node$, "firstChild").get;
var nextSibling$ = getOwnPropertyDescriptor$(node$, "nextSibling").get;
var characterDataSet$ = getOwnPropertyDescriptor$(
  characterData$,
  "data"
).set;
var stringToDOM = (content, svg) => {
  const template = svg ? SVG_TEMPLATE : HTM_TEMPLATE;
  template.innerHTML = content;
  const dom = svg ? SVG_TEMPLATE : HTM_TEMPLATE_CONTENT;
  return dom.firstChild;
};
document$[EVENTS_REGISTRY] = new Set$();
var createEventListener = (el, name, value) => {
  let event = name.toLowerCase();
  let capture = false;
  if (event.endsWith("capture")) {
    event = event.slice(0, -7);
    capture = true;
  }
  const key = `$$${event}`;
  if (!SetHas$.call(document$[EVENTS_REGISTRY], event)) {
    addEventListener$.call(
      document$,
      event,
      (nativeEvent) => {
        let el2 = nativeEvent.target;
        while (el2) {
          const handler = el2[key];
          if (handler) {
            Object$.defineProperty(nativeEvent, "currentTarget", {
              configurable: true,
              get() {
                return el2;
              }
            });
            handler(nativeEvent);
          }
          el2 = el2.parentNode;
        }
      },
      { capture }
    );
    SetAdd$.call(document$[EVENTS_REGISTRY], event);
  }
  const patch2 = (newValue) => {
    var _a;
    if (!newValue) {
      el[key] = null;
    } else if (!("key" in newValue && newValue.key === ((_a = el[key]) == null ? void 0 : _a.key))) {
      el[key] = newValue;
    }
  };
  patch2(value);
  return patch2;
};
var childAt = (el, index) => {
  let child = firstChild$.call(el);
  if (index) {
    for (let j = 0; j < index; ++j) {
      if (!child)
        break;
      child = nextSibling$.call(child);
    }
  }
  return child;
};
var visitedNodes = /* @__PURE__ */ new WeakSet();
var removeComments = (el) => {
  var _a;
  if (visitedNodes.has(el)) {
    return;
  }
  if (el.nodeType === 8) {
    (_a = el.parentNode) == null ? void 0 : _a.removeChild(el);
  }
  let child = firstChild$.call(el);
  while (child) {
    removeComments(child);
    child = child.nextSibling;
  }
  visitedNodes.add(el);
};
var insertText = (el, value, index) => {
  const node = document$.createTextNode(value);
  const child = childAt(el, index);
  insertBefore$.call(el, node, child);
  return node;
};
var setText = (el, value) => {
  characterDataSet$.call(el, value);
};
var setStyleAttribute = (el, name, value) => {
  if (typeof value !== "number" || IS_NON_DIMENSIONAL.test(name)) {
    el.style[name] = value;
  } else if (typeof value === "string") {
    el.style.cssText = value;
  } else if (name.startsWith("-")) {
    el.style.setProperty(name, String(value));
  } else if (value === void 0 || value === null) {
    el.style[name] = "";
  } else {
    el.style[name] = `${String(value)}px`;
  }
};
var setSvgAttribute = (el, name, value) => {
  name = name.replace(/xlink(?:H|:h)/, "h").replace(/sName$/, "s");
  if (name.startsWith("xmlns")) {
    setAttributeNS$.call(el, XML_NS, name, String(value));
  } else if (name.startsWith("xlink")) {
    setAttributeNS$.call(el, XLINK_NS, "href", String(value));
  }
};
var setAttribute = (el, name, value) => {
  const isValueNully = value === void 0 || value === null;
  value = isValueNully ? "" : value;
  if (name in el && el[name] !== void 0 && el[name] !== null && !(el instanceof SVGElement) && SetHas$.call(NON_PROPS, name)) {
    try {
      el[name] = value;
    } catch (_err) {
    }
  } else if (!isValueNully && value !== "" && (value !== false || name.includes("-"))) {
    setAttribute$.call(el, name, String(value));
  } else {
    removeAttribute$.call(el, name);
  }
  const isInput = el instanceof HTMLInputElement;
  const isSelect = el instanceof HTMLSelectElement;
  const isTextArea = el instanceof HTMLTextAreaElement;
  if (name === "value" && (isInput || isSelect || isTextArea)) {
    setAttribute$.call(el, name, String(value));
    el.value = value;
  }
};
var aliases = /* @__PURE__ */ new Map([
  ["acceptCharset", "accept-charset"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"],
  // HTML and SVG attributes, but the SVG attribute is case sensitive.],
  ["crossOrigin", "crossorigin"],
  // This is a list of all SVG attributes that need special casing.
  // Regular attributes that just accept strings.],
  ["accentHeight", "accent-height"],
  ["alignmentBaseline", "alignment-baseline"],
  ["arabicForm", "arabic-form"],
  ["baselineShift", "baseline-shift"],
  ["capHeight", "cap-height"],
  ["clipPath", "clip-path"],
  ["clipRule", "clip-rule"],
  ["colorInterpolation", "color-interpolation"],
  ["colorInterpolationFilters", "color-interpolation-filters"],
  ["colorProfile", "color-profile"],
  ["colorRendering", "color-rendering"],
  ["dominantBaseline", "dominant-baseline"],
  ["enableBackground", "enable-background"],
  ["fillOpacity", "fill-opacity"],
  ["fillRule", "fill-rule"],
  ["floodColor", "flood-color"],
  ["floodOpacity", "flood-opacity"],
  ["fontFamily", "font-family"],
  ["fontSize", "font-size"],
  ["fontSizeAdjust", "font-size-adjust"],
  ["fontStretch", "font-stretch"],
  ["fontStyle", "font-style"],
  ["fontVariant", "font-variant"],
  ["fontWeight", "font-weight"],
  ["glyphName", "glyph-name"],
  ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
  ["glyphOrientationVertical", "glyph-orientation-vertical"],
  ["horizAdvX", "horiz-adv-x"],
  ["horizOriginX", "horiz-origin-x"],
  ["imageRendering", "image-rendering"],
  ["letterSpacing", "letter-spacing"],
  ["lightingColor", "lighting-color"],
  ["markerEnd", "marker-end"],
  ["markerMid", "marker-mid"],
  ["markerStart", "marker-start"],
  ["overlinePosition", "overline-position"],
  ["overlineThickness", "overline-thickness"],
  ["paintOrder", "paint-order"],
  ["panose-1", "panose-1"],
  ["pointerEvents", "pointer-events"],
  ["renderingIntent", "rendering-intent"],
  ["shapeRendering", "shape-rendering"],
  ["stopColor", "stop-color"],
  ["stopOpacity", "stop-opacity"],
  ["strikethroughPosition", "strikethrough-position"],
  ["strikethroughThickness", "strikethrough-thickness"],
  ["strokeDasharray", "stroke-dasharray"],
  ["strokeDashoffset", "stroke-dashoffset"],
  ["strokeLinecap", "stroke-linecap"],
  ["strokeLinejoin", "stroke-linejoin"],
  ["strokeMiterlimit", "stroke-miterlimit"],
  ["strokeOpacity", "stroke-opacity"],
  ["strokeWidth", "stroke-width"],
  ["textAnchor", "text-anchor"],
  ["textDecoration", "text-decoration"],
  ["textRendering", "text-rendering"],
  ["transformOrigin", "transform-origin"],
  ["underlinePosition", "underline-position"],
  ["underlineThickness", "underline-thickness"],
  ["unicodeBidi", "unicode-bidi"],
  ["unicodeRange", "unicode-range"],
  ["unitsPerEm", "units-per-em"],
  ["vAlphabetic", "v-alphabetic"],
  ["vHanging", "v-hanging"],
  ["vIdeographic", "v-ideographic"],
  ["vMathematical", "v-mathematical"],
  ["vectorEffect", "vector-effect"],
  ["vertAdvY", "vert-adv-y"],
  ["vertOriginX", "vert-origin-x"],
  ["vertOriginY", "vert-origin-y"],
  ["wordSpacing", "word-spacing"],
  ["writingMode", "writing-mode"],
  ["xmlnsXlink", "xmlns:xlink"],
  ["xHeight", "x-height"]
]);
function getAttributeAlias(name) {
  return aliases.get(name) || name;
}
var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var AbstractBlock = class {
  constructor() {
    __publicField$1(this, "r");
    __publicField$1(this, "e");
    __publicField$1(this, "l");
    __publicField$1(this, "g");
    __publicField$1(this, "_u");
    __publicField$1(this, "_t");
    __publicField$1(this, "d");
    __publicField$1(this, "k");
    __publicField$1(this, "c");
  }
};
var renderToTemplate = (vnode, edits = [], path = []) => {
  var _a, _b;
  if (typeof vnode === "string")
    return vnode;
  if (typeof vnode === "number" || typeof vnode === "bigint" || vnode === true) {
    return String(vnode);
  }
  if (vnode === null || vnode === void 0 || vnode === false)
    return "";
  if (typeof vnode === "object" && "$" in vnode) {
    edits.push({
      p: path,
      e: [
        {
          /* type */
          t: ChildFlag,
          /* name */
          n: null,
          /* value */
          v: null,
          /* hole */
          h: vnode.$,
          /* index */
          i: 0,
          /* listener */
          l: null,
          /* patch */
          p: null,
          /* block */
          b: null
        }
      ],
      i: []
    });
    return "<slot/>";
  }
  let props = "";
  let children = "";
  const current = {
    p: path,
    // The location of the edit in in the virtual node tree
    e: [],
    // Occur on mount + patch
    i: []
    // Occur before mount
  };
  for (let name in vnode.props) {
    const value = vnode.props[name];
    if (name === "key" || name === "ref" || name === "children") {
      continue;
    }
    const alias = getAttributeAlias(name);
    if (alias)
      name = alias;
    if (name === "className")
      name = "class";
    if (name.startsWith("on")) {
      const isValueHole = "$" in value;
      if (isValueHole) {
        current.e.push({
          /* type */
          t: EventFlag,
          /* name */
          n: name.slice(2),
          /* value */
          v: null,
          /* hole */
          h: value.$,
          /* index */
          i: null,
          /* listener */
          l: null,
          /* patch */
          p: null,
          /* block */
          b: null
        });
      } else {
        current.i.push({
          /* type */
          t: EventFlag,
          /* name */
          n: name.slice(2),
          /* value */
          v: null,
          /* hole */
          h: null,
          /* index */
          i: null,
          /* listener */
          l: value,
          /* patch */
          p: null,
          /* block */
          b: null
        });
      }
      continue;
    }
    if (value) {
      if (typeof value === "object" && "$" in value) {
        if (name === "style") {
          current.e.push({
            /* type */
            t: StyleAttributeFlag,
            /* name */
            n: name,
            /* value */
            v: null,
            /* hole */
            h: value.$,
            /* index */
            i: null,
            /* listener */
            l: null,
            /* patch */
            p: null,
            /* block */
            b: null
          });
        } else if (name.charCodeAt(0) === X_CHAR) {
          current.e.push({
            /* type */
            t: SvgAttributeFlag,
            /* name */
            n: name,
            /* value */
            v: null,
            /* hole */
            h: value.$,
            /* index */
            i: null,
            /* listener */
            l: null,
            /* patch */
            p: null,
            /* block */
            b: null
          });
        } else {
          current.e.push({
            /* type */
            t: AttributeFlag,
            /* name */
            n: name,
            /* value */
            v: null,
            /* hole */
            h: value.$,
            /* index */
            i: null,
            /* listener */
            l: null,
            /* patch */
            p: null,
            /* block */
            b: null
          });
        }
        continue;
      }
      if (name === "style" && typeof value === "object") {
        let style = "";
        for (const key in value) {
          if (typeof value[key] === "object") {
            current.e.push({
              /* type */
              t: StyleAttributeFlag,
              /* name */
              n: key,
              /* value */
              v: null,
              /* hole */
              h: value[key].$,
              /* index */
              i: null,
              /* listener */
              l: null,
              /* patch */
              p: null,
              /* block */
              b: null
            });
            continue;
          }
          let kebabKey = "";
          for (let i = 0, j = key.length; i < j; ++i) {
            const char = key.charCodeAt(i);
            if (char < 97) {
              kebabKey += `-${String.fromCharCode(char + 32)}`;
            } else {
              kebabKey += key[i];
            }
          }
          style += `${kebabKey}:${String(value[key])};`;
        }
        props += ` style="${style}"`;
        continue;
      }
      props += ` ${name}="${String(value)}"`;
    }
  }
  if (SetHas$.call(VOID_ELEMENTS, vnode.type)) {
    if (current.e.length)
      edits.push(current);
    return `<${vnode.type}${props} />`;
  }
  let canMergeString = false;
  for (let i = 0, j = ((_a = vnode.props.children) == null ? void 0 : _a.length) || 0, k = 0; i < j; ++i) {
    const child = (_b = vnode.props.children) == null ? void 0 : _b[i];
    if (child === null || child === void 0 || child === false)
      continue;
    if (typeof child === "object" && "$" in child) {
      current.e.push({
        /* type */
        t: ChildFlag,
        /* name */
        n: null,
        /* value */
        v: null,
        /* hole */
        h: child.$,
        /* index */
        i,
        /* listener */
        l: null,
        /* patch */
        p: null,
        /* block */
        b: null
      });
      continue;
    }
    if (child instanceof AbstractBlock) {
      current.i.push({
        /* type */
        t: BlockFlag,
        /* name */
        n: null,
        /* value */
        v: null,
        /* hole */
        h: null,
        /* index */
        i,
        /* listener */
        l: null,
        /* patch */
        p: null,
        /* block */
        b: child
      });
      continue;
    }
    if (typeof child === "string" || typeof child === "number" || typeof child === "bigint") {
      const value = typeof child === "number" || typeof child === "bigint" ? String(child) : child;
      if (canMergeString) {
        current.i.push({
          /* type */
          t: ChildFlag,
          /* name */
          n: null,
          /* value */
          v: value,
          /* hole */
          h: null,
          /* index */
          i,
          /* listener */
          l: null,
          /* patch */
          p: null,
          /* block */
          b: null
        });
        continue;
      }
      canMergeString = true;
      children += value;
      k++;
      continue;
    }
    canMergeString = false;
    const newPath = path.slice();
    newPath.push(k++);
    children += renderToTemplate(child, edits, newPath);
  }
  if (current.i.length || current.e.length)
    edits.push(current);
  return `<${vnode.type}${props}>${children}</${vnode.type}>`;
};
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var mapArray = (children) => {
  return new ArrayBlock(children);
};
var ArrayBlock = class extends AbstractBlock {
  constructor(children) {
    super();
    __publicField(this, "b");
    this.b = children;
  }
  v() {
  }
  p(fragment) {
    const oldChildren = this.b;
    const newChildren = fragment.b;
    const oldChildrenLength = oldChildren.length;
    const newChildrenLength = newChildren.length;
    const parent = this.t();
    if (this === fragment)
      return parent;
    if (newChildrenLength === 0 && oldChildrenLength === 0)
      return parent;
    this.b = newChildren;
    if (newChildrenLength === 0) {
      arrayRemove$.call(this);
      return parent;
    }
    if (oldChildrenLength === 0) {
      arrayMount$.call(fragment, parent);
      return parent;
    }
    let oldHead = 0;
    let newHead = 0;
    let oldTail = oldChildrenLength - 1;
    let newTail = newChildrenLength - 1;
    let oldHeadChild = oldChildren[0];
    let newHeadChild = newChildren[0];
    let oldTailChild = oldChildren[oldTail];
    let newTailChild = newChildren[newTail];
    let oldKeyMap;
    while (oldHead <= oldTail && newHead <= newTail) {
      if (!oldHeadChild) {
        oldHeadChild = oldChildren[++oldHead];
        continue;
      }
      if (!oldTailChild) {
        oldTailChild = oldChildren[--oldTail];
        continue;
      }
      const oldHeadKey = oldHeadChild.k;
      const newHeadKey = newHeadChild.k;
      if (oldHeadKey === newHeadKey) {
        patch$.call(oldHeadChild, newHeadChild);
        newChildren[newHead] = oldHeadChild;
        oldHeadChild = oldChildren[++oldHead];
        newHeadChild = newChildren[++newHead];
        continue;
      }
      const oldTailKey = oldTailChild.k;
      const newTailKey = newTailChild.k;
      if (oldTailKey === newTailKey) {
        patch$.call(oldTailChild, newTailChild);
        newChildren[newTail] = oldTailChild;
        oldTailChild = oldChildren[--oldTail];
        newTailChild = newChildren[--newTail];
        continue;
      }
      if (oldHeadKey === newTailKey) {
        patch$.call(oldHeadChild, newTailChild);
        newChildren[newTail] = oldHeadChild;
        const nextChild = newChildren[newTail + 1];
        move$.call(oldHeadChild, nextChild, (nextChild == null ? void 0 : nextChild.l) || null);
        oldHeadChild = oldChildren[++oldHead];
        newTailChild = newChildren[--newTail];
        continue;
      }
      if (oldTailKey === newHeadKey) {
        patch$.call(oldTailChild, newHeadChild);
        newChildren[newHead] = oldTailChild;
        const nextChild = oldChildren[oldHead];
        move$.call(oldTailChild, nextChild, (nextChild == null ? void 0 : nextChild.l) || null);
        oldTailChild = oldChildren[--oldTail];
        newHeadChild = newChildren[++newHead];
        continue;
      }
      if (!oldKeyMap) {
        oldKeyMap = new Map$();
        for (let i = oldHead; i <= oldTail; i++) {
          MapSet$.call(oldKeyMap, oldChildren[i].k, i);
        }
      }
      const oldIndex = oldKeyMap.get(newHeadKey);
      if (oldIndex === void 0) {
        mount$.call(newHeadChild, parent, oldHeadChild.l || null);
      } else {
        const oldChild = oldChildren[oldIndex];
        move$.call(oldChild, oldHeadChild, null);
        patch$.call(oldChild, newHeadChild);
        newChildren[newHead] = oldChild;
        oldChildren[oldIndex] = null;
      }
      newHeadChild = newChildren[++newHead];
    }
    if (oldHead <= oldTail || newHead <= newTail) {
      if (oldHead > oldTail) {
        const nextChild = newChildren[newTail + 1];
        for (let i = newHead; i <= newTail; ++i) {
          mount$.call(newChildren[i], parent, nextChild ? nextChild.l : null);
        }
      } else {
        for (let i = oldHead; i <= oldTail; ++i) {
          remove$.call(oldChildren[i]);
        }
      }
    }
    return parent;
  }
  m(parent, refNode = null) {
    if (this._t)
      return this._t;
    for (let i = 0, j = this.b.length; i < j; ++i) {
      const block3 = this.b[i];
      mount$.call(block3, parent, refNode);
    }
    this._t = parent;
    return parent;
  }
  x() {
    const parent = this.t();
    if (parent) {
      setTextContent$.call(parent, "");
    } else {
      for (let i = 0, j = this.b.length; i < j; ++i) {
        remove$.call(this.b[i]);
      }
    }
    this.b = [];
  }
  u() {
    return true;
  }
  s() {
    return this.b.map((block3) => block3.s()).join("");
  }
  t() {
    if (!this._t)
      this._t = this.b[0].t();
    return this._t;
  }
};
var array$ = ArrayBlock.prototype;
var arrayMount$ = array$.m;
var arrayPatch$ = array$.p;
var arrayRemove$ = array$.x;
var HOLE_PROXY = new Proxy(
  {},
  {
    // A universal getter will return a Hole instance if props[any] is accessed
    // Allows code to identify holes in virtual nodes ("digs" them out)
    get(_, key) {
      return { $: key };
    }
  }
);
var block = (fn, unwrap2, shouldUpdate, svg) => {
  const vnode = fn(HOLE_PROXY);
  const edits = [];
  const root = stringToDOM(
    renderToTemplate(unwrap2 ? unwrap2(vnode) : vnode, edits),
    svg
  );
  removeComments(root);
  return (props, key, shouldUpdateCurrentBlock) => {
    return new Block(
      root,
      edits,
      props,
      key ?? (props == null ? void 0 : props.key) ?? null,
      shouldUpdateCurrentBlock ?? shouldUpdate ?? null,
      null
    );
  };
};
var mount = (block22, parent, hydrateNode) => {
  if ("b" in block22 && parent) {
    return arrayMount$.call(block22, parent, null);
  }
  return mount$.call(block22, parent, null, hydrateNode);
};
var patch = (oldBlock, newBlock) => {
  if ("b" in oldBlock || "b" in newBlock) {
    arrayPatch$.call(oldBlock, newBlock);
  }
  if (!oldBlock.l)
    mount$.call(oldBlock, void 0, null, null);
  if (oldBlock.k && oldBlock.k === newBlock.k || oldBlock.r === newBlock.r) {
    return patch$.call(oldBlock, newBlock);
  }
  const el = mount$.call(newBlock, oldBlock.t(), oldBlock.l, null);
  remove$.call(oldBlock);
  oldBlock.k = newBlock.k;
  return el;
};
var Block = class extends AbstractBlock {
  constructor(root, edits, props, key, shouldUpdate, getElements) {
    super();
    this.r = root;
    this.d = props;
    this.e = edits;
    this.k = key;
    this.c = Array(edits.length);
    if (shouldUpdate) {
      this._u = shouldUpdate;
    } else {
      this._u = null;
    }
    if (getElements) {
      this.g = getElements;
    } else {
      this.g = null;
    }
  }
  m(parent, refNode = null, hydrateNode) {
    var _a, _b;
    if (this.l)
      return this.l;
    const root = hydrateNode ?? cloneNode$.call(this.r, true);
    const elements = (_a = this.g) == null ? void 0 : _a.call(this, root);
    if (elements)
      this.c = elements;
    for (let i = 0, j = this.e.length; i < j; ++i) {
      const current = this.e[i];
      const el = (elements == null ? void 0 : elements[i]) ?? getCurrentElement(current.p, root, this.c, i);
      for (let k = 0, l = current.e.length; k < l; ++k) {
        const edit = current.e[k];
        const value = this.d[edit.h];
        if (edit.t & ChildFlag) {
          if (value instanceof AbstractBlock) {
            const child = childAt(el, edit.i);
            if (hydrateNode) {
              value.m(el, child, child);
            } else {
              value.m(el, child);
            }
            continue;
          }
          if (!el[TEXT_NODE_CACHE])
            el[TEXT_NODE_CACHE] = new Array(l);
          if (value && typeof value === "object" && "foreign" in value) {
            if (hydrateNode) {
              const child = childAt(el, edit.i);
              value.reset(child);
            }
            const targetEl = value.current;
            el[TEXT_NODE_CACHE][k] = targetEl;
            if (!hydrateNode) {
              insertBefore$.call(el, targetEl, childAt(el, edit.i));
            }
            continue;
          }
          if (hydrateNode) {
            el[TEXT_NODE_CACHE][k] = childAt(el, edit.i);
            continue;
          }
          el[TEXT_NODE_CACHE][k] = insertText(
            el,
            // eslint-disable-next-line eqeqeq
            value == null || value === false ? "" : String(value),
            edit.i
          );
        } else if (edit.t & EventFlag) {
          const patch2 = createEventListener(el, edit.n, value);
          el[EVENT_PATCH + edit.n] = patch2;
        } else if (edit.t & AttributeFlag) {
          setAttribute(el, edit.n, value);
        } else if (edit.t & StyleAttributeFlag) {
          if (typeof value === "string" || typeof value === "number") {
            setStyleAttribute(el, edit.n, value);
          } else {
            for (const style in value) {
              setStyleAttribute(el, style, value[style]);
            }
          }
        } else {
          setSvgAttribute(el, edit.n, value);
        }
      }
      const initsLength = (_b = current.i) == null ? void 0 : _b.length;
      if (!initsLength)
        continue;
      for (let k = 0; k < initsLength; ++k) {
        const init = current.i[k];
        if (init.t & ChildFlag) {
          if (init.v && !hydrateNode)
            insertText(el, init.v, init.i);
        } else if (init.t & EventFlag) {
          createEventListener(el, init.n, init.l);
        } else {
          const child = childAt(el, init.i);
          if (hydrateNode) {
            init.b.m(el, child, child);
          } else {
            init.b.m(el, child);
          }
        }
      }
    }
    if (parent && !hydrateNode) {
      insertBefore$.call(parent, root, refNode);
    }
    this.l = root;
    return root;
  }
  p(newBlock) {
    var _a, _b;
    const root = this.l;
    if (!newBlock.d)
      return root;
    const props = this.d;
    if (!shouldUpdate$.call(this, props, newBlock.d))
      return root;
    this.d = newBlock.d;
    for (let i = 0, j = this.e.length; i < j; ++i) {
      const current = this.e[i];
      const el = this.c[i] ?? getCurrentElement(current.p, root, this.c, i);
      for (let k = 0, l = current.e.length; k < l; ++k) {
        const edit = current.e[k];
        const oldValue = props[edit.h];
        const newValue = newBlock.d[edit.h];
        if (newValue === oldValue)
          continue;
        if (edit.t & EventFlag) {
          el[EVENT_PATCH + edit.n](newValue);
          continue;
        }
        if (edit.t & ChildFlag) {
          if (oldValue instanceof AbstractBlock) {
            const firstEdit = (_b = (_a = newBlock.e) == null ? void 0 : _a[i]) == null ? void 0 : _b.e[k];
            const newChildBlock = newBlock.d[firstEdit.h];
            oldValue.p(newChildBlock);
            continue;
          }
          if (newValue && typeof newValue === "object" && "foreign" in newValue) {
            const targetEl = el[TEXT_NODE_CACHE][k];
            if (newValue.unstable && oldValue !== newValue) {
              const newTargetEl = newValue.current;
              el[TEXT_NODE_CACHE][k] = newTargetEl;
              replaceChild$.call(el, newTargetEl, targetEl);
            } else {
              newValue.current = targetEl;
            }
            continue;
          }
          setText(
            el[TEXT_NODE_CACHE][k],
            // eslint-disable-next-line eqeqeq
            newValue == null || newValue === false ? "" : String(newValue)
          );
        } else if (edit.t & AttributeFlag) {
          setAttribute(el, edit.n, newValue);
        } else if (edit.t & StyleAttributeFlag) {
          if (typeof newValue === "string" || typeof newValue === "number") {
            setStyleAttribute(el, edit.n, newValue);
          } else {
            for (const style in newValue) {
              if (newValue[style] !== oldValue[style]) {
                setStyleAttribute(el, style, newValue[style]);
              }
            }
          }
        } else {
          setSvgAttribute(el, edit.n, newValue);
        }
      }
    }
    return root;
  }
  v(block22 = null, refNode = null) {
    insertBefore$.call(this.t(), this.l, block22 ? block22.l : refNode);
  }
  x() {
    remove$$1.call(this.l);
    this.l = null;
  }
  u(_oldProps, _newProps) {
    if (!this._u)
      return true;
    return this._u(_oldProps, _newProps);
  }
  s() {
    var _a;
    return String((_a = this.l) == null ? void 0 : _a.outerHTML);
  }
  t() {
    var _a;
    if (!this._t)
      this._t = (_a = this.l) == null ? void 0 : _a.parentElement;
    return this._t;
  }
};
var getCurrentElement = (path, root, cache, key) => {
  const pathLength = path.length;
  if (!pathLength)
    return root;
  const isCacheAndKeyExists = cache && key !== void 0;
  if (isCacheAndKeyExists && cache[key]) {
    return cache[key];
  }
  for (let i = 0; i < pathLength; ++i) {
    const siblings = path[i];
    root = childAt(root, siblings);
  }
  if (isCacheAndKeyExists)
    cache[key] = root;
  return root;
};
var block$ = Block.prototype;
var mount$ = block$.m;
var patch$ = block$.p;
var move$ = block$.v;
var remove$ = block$.x;
var shouldUpdate$ = block$.u;

// node_modules/million/dist/packages/react.mjs
var import_react2 = __toESM(require_react(), 1);

// node_modules/million/dist/packages/experimental.mjs
var experimental_options = {
  noSlot: false
};

// node_modules/million/dist/shared/million.9efd57f2.mjs
var import_react = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var RENDER_SCOPE = "slot";
var SVG_RENDER_SCOPE = "g";
var Effect = ({
  effect,
  deps
}) => {
  (0, import_react.useEffect)(effect, deps || []);
  return null;
};
var REGISTRY = /* @__PURE__ */ new Map();
var scopedContext = (0, import_react.createContext)(false);
var processProps = (props, ref, portals) => {
  const processedProps = { ref };
  let currentIndex = 0;
  for (const key in props) {
    const value = props[key];
    if ((0, import_react.isValidElement)(value) || Array.isArray(value) && value.length && (0, import_react.isValidElement)(value[0])) {
      processedProps[key] = renderReactScope(
        value,
        false,
        portals,
        currentIndex++
      );
      continue;
    }
    processedProps[key] = props[key];
  }
  return processedProps;
};
var wrap = (vnode, key) => {
  return (0, import_react.createElement)(
    RENDER_SCOPE,
    { suppressHydrationWarning: true, id: key },
    vnode
  );
};
var renderReactScope = (vnode, unstable, portals, currentIndex, key) => {
  var _a;
  const el = (_a = portals == null ? void 0 : portals[currentIndex]) == null ? void 0 : _a.current;
  const isBlock = (0, import_react.isValidElement)(vnode) && typeof vnode.type === "function" && "_c" in vnode.type;
  const isCallable = isBlock && vnode.type._c;
  if (typeof window === "undefined") {
    if (isBlock) {
      if (isCallable) {
        return vnode;
      }
      return wrap(wrap(vnode), key);
    }
    return wrap(vnode, key);
  }
  if (isCallable) {
    const puppetComponent = vnode.type(vnode.props);
    if (REGISTRY.has(puppetComponent.type)) {
      const puppetBlock = REGISTRY.get(puppetComponent.type);
      if (typeof puppetBlock === "function") {
        return puppetBlock(puppetComponent.props);
      }
    }
  }
  const current = el ?? (key ? document.getElementById(key) : null) ?? document.createElement(RENDER_SCOPE);
  const reactPortal = (0, import_react_dom.createPortal)(
    (0, import_react.createElement)(import_react.Fragment, { children: vnode }),
    current,
    key
  );
  const millionPortal = {
    foreign: true,
    current,
    portal: reactPortal,
    reset: (child) => {
      child.childNodes.forEach((cn) => child.removeChild(cn));
    },
    unstable
  };
  if (portals) {
    portals[currentIndex] = millionPortal;
  }
  return millionPortal;
};
var unwrap = (vnode) => {
  var _a;
  if (typeof vnode !== "object" || vnode === null || !("type" in vnode)) {
    if (typeof vnode === "number") {
      return String(vnode);
    }
    return vnode;
  }
  let type = vnode.type;
  if (typeof type === "function") {
    return unwrap(type(vnode.props ?? {}));
  }
  if (typeof type === "object" && "$" in type)
    return type;
  const props = { ...vnode.props };
  if ("css" in props && "__EMOTION_TYPE_PLEASE_DO_NOT_USE__" in props) {
    props.style = props.css.styles;
    type = props.__EMOTION_TYPE_PLEASE_DO_NOT_USE__;
    delete props.__EMOTION_TYPE_PLEASE_DO_NOT_USE__;
    delete props.css;
  }
  const children = (_a = vnode.props) == null ? void 0 : _a.children;
  if (children !== void 0 && children !== null) {
    props.children = flatten(vnode.props.children).map(
      (child) => unwrap(child)
    );
  }
  return {
    type,
    // lets pretend no function go through
    props
  };
};
var flatten = (rawChildren) => {
  if (rawChildren === void 0 || rawChildren === null)
    return [];
  if (typeof rawChildren === "object" && "type" in rawChildren && rawChildren.type === import_react.Fragment) {
    return flatten(rawChildren.props.children);
  }
  if (!Array.isArray(rawChildren) || typeof rawChildren === "object" && "$" in rawChildren) {
    return [rawChildren];
  }
  const flattenedChildren = rawChildren.flat(Infinity);
  const children = [];
  for (let i = 0, l = flattenedChildren.length; i < l; ++i) {
    children.push(...flatten(flattenedChildren[i]));
  }
  return children;
};
var useLayoutEffect = typeof window === "undefined" ? import_react.useEffect : import_react.useLayoutEffect;
function traverse(fiber, selector, ascending) {
  if (!fiber || selector(fiber))
    return fiber;
  let child = ascending ? fiber.return : fiber.child;
  while (child) {
    const match = traverse(child, selector, ascending);
    if (match)
      return match;
    child = ascending ? null : child.sibling;
  }
}
function useFiber() {
  const fiber = (0, import_react.useRef)();
  (0, import_react.useState)(() => {
    const bind = Function.prototype.bind;
    Function.prototype.bind = function(self, maybeFiber) {
      if (self === null && typeof (maybeFiber == null ? void 0 : maybeFiber.type) === "function") {
        fiber.current = maybeFiber;
        Function.prototype.bind = bind;
      }
      return bind.apply(this, arguments);
    };
  });
  return fiber.current;
}
function useNearestParent(type) {
  const fiber = useFiber();
  const parentRef = (0, import_react.useRef)({ el: null, depth: 0 });
  useLayoutEffect(() => {
    var _a;
    parentRef.current.el = (_a = traverse(
      fiber,
      (node) => {
        parentRef.current.depth++;
        return typeof node.type === "string" && (type === void 0 || node.type === type);
      },
      true
    )) == null ? void 0 : _a.stateNode;
  }, [fiber]);
  return parentRef;
}
function useContainer() {
  const fiber = useFiber();
  const rootRef = (0, import_react.useRef)({ el: null, depth: 0 });
  useLayoutEffect(() => {
    var _a;
    rootRef.current.el = (_a = traverse(
      fiber,
      (node) => {
        var _a2;
        rootRef.current.depth++;
        return ((_a2 = node.stateNode) == null ? void 0 : _a2.containerInfo) != null;
      },
      true
    )) == null ? void 0 : _a.stateNode.containerInfo;
  }, [fiber]);
  return rootRef;
}

// node_modules/million/dist/packages/react.mjs
var import_react_dom2 = __toESM(require_react_dom(), 1);
var block2 = (fn, options = {}) => {
  const noSlot = (options == null ? void 0 : options.experimental_noSlot) ?? experimental_options.noSlot;
  let blockTarget = options == null ? void 0 : options.block;
  const defaultType = (options == null ? void 0 : options.svg) ? SVG_RENDER_SCOPE : RENDER_SCOPE;
  if (fn) {
    blockTarget = block(
      fn,
      unwrap,
      options == null ? void 0 : options.shouldUpdate,
      options == null ? void 0 : options.svg
    );
  }
  const MillionBlock = (props, forwardedRef) => {
    var _a, _b;
    const container = useContainer();
    const parentRef = useNearestParent();
    const hmrTimestamp = props._hmr;
    const ref = (0, import_react2.useRef)(null);
    const patch$1 = (0, import_react2.useRef)(null);
    const portalRef = (0, import_react2.useRef)([]);
    props = processProps(props, forwardedRef, portalRef.current);
    (_a = patch$1.current) == null ? void 0 : _a.call(patch$1, props);
    const effect = (0, import_react2.useCallback)(() => {
      var _a2, _b2, _c;
      if (!ref.current && !noSlot)
        return;
      const currentBlock = blockTarget(props, props.key);
      if (hmrTimestamp && ((_a2 = ref.current) == null ? void 0 : _a2.textContent)) {
        ref.current.textContent = "";
      }
      if (noSlot) {
        ref.current = ((_b2 = parentRef.current) == null ? void 0 : _b2.el) ?? ((_c = container.current) == null ? void 0 : _c.el);
        if (props.scoped || parentRef.current && container.current && parentRef.current.depth > container.current.depth) {
          ref.current = container.current.el;
        }
        if (ref.current.childNodes.length) {
          console.error(
            new Error(`\`experimental_options.noSlot\` does not support having siblings at the moment.
The block element should be the only child of the \`${cloneNode$.call(ref.current).outerHTML}\` element.
To avoid this error, \`experimental_options.noSlot\` should be false`)
          );
        }
      }
      if (patch$1.current === null || hmrTimestamp) {
        mount$.call(currentBlock, ref.current, null);
        patch$1.current = (props2) => {
          patch(
            currentBlock,
            blockTarget(
              props2,
              props2.key,
              options == null ? void 0 : options.shouldUpdate
            )
          );
        };
      }
      return () => {
        remove$.call(currentBlock);
      };
    }, []);
    const marker = (0, import_react2.useMemo)(() => {
      if (noSlot) {
        return null;
      }
      return (0, import_react2.createElement)((options == null ? void 0 : options.as) ?? defaultType, { ref });
    }, []);
    const childrenSize = portalRef.current.length;
    const children = new Array(childrenSize);
    for (let i = 0; i < childrenSize; ++i) {
      children[i] = (_b = portalRef.current[i]) == null ? void 0 : _b.portal;
    }
    const vnode = (0, import_react2.createElement)(
      import_react2.Fragment,
      {},
      marker,
      (0, import_react2.createElement)(Effect, {
        effect,
        deps: hmrTimestamp ? [hmrTimestamp] : []
      }),
      children
    );
    return vnode;
  };
  if (!MapHas$.call(REGISTRY, MillionBlock)) {
    MapSet$.call(REGISTRY, MillionBlock, block2);
  }
  if (options == null ? void 0 : options.name) {
    if (fn) {
      fn.displayName = `Million(Render(${options.name}))`;
    }
    MillionBlock.displayName = `Million(Block(${options.name}))`;
  }
  return MillionBlock;
};
var MillionArray = ({
  each,
  children,
  memo: memo2,
  svg,
  as,
  ...rest
}) => {
  const ref = (0, import_react2.useRef)(null);
  const [portals] = (0, import_react2.useState)(() => ({
    current: Array(each.length)
  }));
  const fragmentRef = (0, import_react2.useRef)(null);
  const cache = (0, import_react2.useRef)({
    each: null,
    children: null,
    mounted: false
  });
  const [, setMountPortals] = (0, import_react2.useState)(false);
  if (fragmentRef.current && (each !== cache.current.each || !memo2)) {
    const newChildren = createChildren(each, children, cache, portals, memo2);
    arrayPatch$.call(fragmentRef.current, mapArray(newChildren));
  }
  const defaultType = svg ? SVG_RENDER_SCOPE : RENDER_SCOPE;
  const MillionFor = (0, import_react2.createElement)(
    import_react2.Fragment,
    null,
    (0, import_react2.createElement)(as ?? defaultType, { ...rest, ref }),
    ...portals.current.map((p) => p.portal)
  );
  (0, import_react2.useEffect)(() => {
    if (!ref.current || fragmentRef.current)
      return;
    if (cache.current.mounted)
      return;
    const newChildren = createChildren(each, children, cache, portals, memo2);
    fragmentRef.current = mapArray(newChildren);
    if (!MapHas$.call(REGISTRY, MillionFor)) {
      MapSet$.call(REGISTRY, MillionFor, fragmentRef.current);
    }
    arrayMount$.call(fragmentRef.current, ref.current);
    cache.current.mounted = true;
    setMountPortals(true);
  }, [ref.current]);
  return MillionFor;
};
var typedMemo = import_react2.memo;
var For = typedMemo(MillionArray);
var createChildren = (each, getComponent, cache, portals, memo2) => {
  var _a;
  const children = Array(each.length);
  const currentCache = cache.current;
  for (let i = 0, l = each.length; i < l; ++i) {
    if (memo2 && currentCache.each && currentCache.each[i] === each[i]) {
      children[i] = (_a = currentCache.children) == null ? void 0 : _a[i];
      continue;
    }
    const vnode = getComponent(each[i], i);
    if (MapHas$.call(REGISTRY, vnode.type)) {
      if (!currentCache.block) {
        currentCache.block = MapGet$.call(REGISTRY, vnode.type);
      }
      children[i] = currentCache.block(vnode.props, portals, i);
      continue;
    }
    if (typeof vnode.type === "function" && "_c" in vnode.type) {
      const puppetComponent = vnode.type(vnode.props);
      if (MapHas$.call(REGISTRY, puppetComponent.type)) {
        const puppetBlock = MapGet$.call(REGISTRY, puppetComponent.type);
        if (typeof puppetBlock === "function") {
          children[i] = puppetBlock(puppetComponent.props);
          continue;
        }
      }
    }
    const block3 = block((props) => props == null ? void 0 : props.scope);
    const currentBlock = (props, portals2, index) => {
      return block3(
        {
          scope: renderReactScope(
            (0, import_react2.createElement)(vnode.type, props),
            false,
            portals2.current,
            index
          )
        },
        vnode.key ? String(vnode.key) : void 0
      );
    };
    MapSet$.call(REGISTRY, vnode.type, currentBlock);
    currentCache.block = currentBlock;
    children[i] = currentBlock(vnode.props, portals, i);
  }
  currentCache.each = each;
  currentCache.children = children;
  return children;
};
function isEqual(a, b) {
  return a === b || a !== a && b !== b;
}
function shouldCompiledBlockUpdate(prev, next) {
  for (const key in prev) {
    if (!isEqual(prev[key], next[key])) {
      return true;
    }
  }
  return false;
}
function compiledBlock(render, { portals, ...options }) {
  const blockName = `CompiledBlock(Inner(${options.name}))`;
  const RenderBlock = block2((props) => render(props), {
    ...options,
    scoped: void 0,
    name: blockName,
    shouldUpdate: shouldCompiledBlockUpdate
  });
  const portalCount = (portals == null ? void 0 : portals.length) || 0;
  const Component = portals && portalCount > 0 ? (props) => {
    const scoped = (0, import_react2.useContext)(scopedContext);
    const [current] = (0, import_react2.useState)(() => []);
    const derived = { ...props, scoped };
    for (let i = 0; i < portalCount; i++) {
      const index = portals[i];
      const scope = renderReactScope(
        derived[index],
        false,
        current,
        i
      );
      derived[index] = scope;
    }
    const targets = [];
    for (let i = 0, len = current.length; i < len; i++) {
      targets[i] = current[i].portal;
    }
    return (0, import_react2.createElement)(
      import_react2.Fragment,
      null,
      (0, import_react2.createElement)(RenderBlock, derived),
      targets
    );
  } : (props) => (0, import_react2.createElement)(RenderBlock, props);
  if (options.name) {
    Component.displayName = `Million(CompiledBlock(Outer(${options.name})))`;
  }
  return Component;
}
var INTERNALS = {
  block,
  patch,
  mount
};
if (typeof window !== "undefined") {
  window.__MILLION_DATA__ = {
    version: "3.1.11"
  };
}
export {
  For,
  INTERNALS,
  REGISTRY,
  block2 as block,
  compiledBlock,
  removeComments,
  renderReactScope,
  unwrap
};
//# sourceMappingURL=million_react.js.map
